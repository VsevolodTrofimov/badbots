from __future__ import print_function
from vizdoom import *
from time import sleep

# Create DoomGame instance. It will run the game and communicate with you.
game = DoomGame()

# Now it's time for configuration!
# load_config could be used to load configuration instead of doing it here with code.
# If load_config is used in - code configuration will work. Note that the most recent changes will add to previous ones.
game.load_config("../../examples/config/basic.cfg")

# Sets path to vizdoom engine executive which will be spawned as a separate process. Default is "./vizdoom".
game.set_vizdoom_path("../../bin/vizdoom")

# Sets path to doom2 iwad resource file which contains the actual doom game. Default is "./doom2.wad".
game.set_doom_game_path("../../scenarios/freedoom2.wad")

# Sets path to additional resources iwad file which is basically your scenario iwad.
# If not specified default doom2 maps will be used and it's pretty much useles... unless you want to play doom.
game.set_doom_scenario_path("../../scenarios/basic.wad")

# Sets map to start (scenario .wad files can contain many maps).
game.set_doom_map("map01")

# Sets resolution. Default is 320X240
game.set_screen_resolution(ScreenResolution.RES_640X480)

# Sets the screen buffer format. Not used here but now you can change it. Defalut is CRCGCB.
game.set_screen_format(ScreenFormat.RGB24)

# Sets other rendering options
game.set_render_hud(False)
game.set_render_crosshair(False)
game.set_render_weapon(False)
game.set_render_decals(False)
game.set_render_particles(False)

# Adds buttons that will be allowed. 
game.add_available_button(Button.forward)
game.add_available_button(Button.backward)
game.add_available_button(Button.strife_left)
game.add_available_button(Button.strife_right)
game.add_available_button(Button.turn_left)
game.add_available_button(Button.turn_right)
game.add_available_button(Button.attack)
game.add_available_button(Button.weapon_1)
game.add_available_button(Button.weapon_2)
game.add_available_button(Button.weapon_3)
game.add_available_button(Button.weapon_4)
game.add_available_button(Button.weapon_5)
game.add_available_button(Button.weapon_6)

# Adds game variables that will be included in state.
game.add_available_game_variable(GameVariable.AMMO2)

# Causes episodes to finish after 200 tics (actions)
game.set_episode_timeout(200)

# Makes episodes start after 10 tics (after raising the weapon)
game.set_episode_start_time(10)

# Makes the window appear (turned on by default)
game.set_window_visible(True)

# Turns on the sound. (turned off by default)
game.set_sound_enabled(True)

# Sets the livin reward (for each move) to -1
game.set_living_reward(-1)

# Sets ViZDoom mode (PLAYER, ASYNC_PLAYER, SPECTATOR, ASYNC_SPECTATOR, PLAYER mode is default)
game.set_mode(Mode.PLAYER)

# Initialize the game. Further configuration won't take any effect from now on.
game.init()

# Run this many episodes
episodes = 10

for i in range(episodes):
    print("Episode #" + str(i + 1))

    # Starts a new episode. It is not needed right after init() but it doesn't cost much. At least the loop is nicer.
    game.new_episode()

    while not game.is_episode_finished():

    	# Gets the state
        s = game.get_state()
        # s.number
        # s.game_variables
        # s.image_buffer

        r = game.make_action(decode)

        # Prints state's game variables.
        print("State #" + str(s.number))
        print("Game variables:", s.game_variables[0])
        #print("Reward:", r)
        print("=====================")

    # Check how the episode went.
    print("Episode finished.")
    print("total reward:", game.get_total_reward())
    print("************************")

# It will be done automatically anyway but sometimes you need to do it in the middle of the program...
game.close()


decode(commands):
	
    for i in range(13):
        act[i] = False
        
    if "forward" in commands:
        act[0] = True

    if "backward" in commands:
        act[1] = True

    if "strife_left" in commands:
        act[2] = True

    if "strif_right" in commands:
        act[3] = True

    if "turn_left" in commands:
        act[4] = True

    if "turn_right" in commands:
        act[5] = True

    if "attack" in commands:
        act[6] = True

    if "weapon_1" in commands:
        act[7] = True

    if "weapon_2" in commands:
        act[8] = True

    if "weapon_3" in commands:
        act[9] = True

    if "weapon_4" in commands:
        act[10] = True

    if "weapon_5" in commands:
        act[11] = True

    if "weapon_6" in commands:
        act[12] = True

return act 